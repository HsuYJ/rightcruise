// rightCruise.js

// (polyfill)define window.requestAnimationFrame
window.requestAnimationFrame = (function() {
	return window.requestAnimationFrame ||
		   window.msRequestAnimationFrame ||
		   window.mozRequestAnimationFrame ||
		   window.webkitRequestAnimationFrame ||
		   function(callback) {
		   	window.setTimeout(callback, 1000 / 60);
		   };
}());
// (polyfill)define element.classList
// original source: https://github.com/remy/polyfills/blob/master/classList.js
(function () {

	if (typeof window.Element === undefined || 'classList' in document.documentElement) { return; }

	var prototype = Array.prototype,
		push = prototype.push,
		splice = prototype.splice,
		join = prototype.join;

	function DOMTokenList(el) {
		this.el = el;
		// The className needs to be trimmed and split on whitespace
		// to retrieve a list of classes.
		var classes = el.className.replace(/^\s+|\s+$/g,'').split(/\s+/);
		var i;

		for (i = 0; i < classes.length; i++) {
			push.call(this, classes[i]);
		}
	}

	DOMTokenList.prototype = {
		add: function(token) {

			var args = arguments[0];
			var i;

			for (i = 0; i< args.length; i++) {
				if(this.contains(args[i])) { continue; }

				push.call(this, args[i]);
				this.el.className = this.toString();
			}
		},
		contains: function(token) {

			return (this.el.className.indexOf(token) !== -1);
		},
		item: function(index) {

			return (this[index] || null);
		},
		remove: function(token) {

			var args = arguments;
			var i;

			for (i = 0; i< args.length; i++) {
				if (!this.contains(args[i])) { continue; }

				var j;

				for (j = 0; j < this.length; j++) {
					if (this[j] === args[i]) {
						splice.call(this, j, 1);
						break;
					}
				}

				this.el.className = this.toString();
			}
		},
		toString: function() {

			return join.call(this, ' ');
		},
		toggle: function(token) {

			if (!this.contains(token)) {
				this.add(token);
			} else {
				this.remove(token);
			}

			return this.contains(token);
		}
	};

	window.DOMTokenList = DOMTokenList;

	function defineElementGetter (obj, prop, getter) {

		if (Object.defineProperty) {
			Object.defineProperty(obj, prop,{
				get : getter
			});
		} else {
			obj.__defineGetter__(prop, getter);
		}
	}

	defineElementGetter(Element.prototype, 'classList', function () {
		return new DOMTokenList(this);
	});
})();
// (polyfill)defined CustomEvent()
// original source: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
(function () {
	// if CustomEvent() is natively supported, modify nothing
	if (typeof CustomEvent === 'function') { return; }

	function customEvent(event, params) {
		params = params || {bubbles: false, cancelable: false, detail: undefined};

		var evt = document.createEvent('CustomEvent');

		evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);

		return evt;
	}

	customEvent.prototype = window.Event.prototype;
	window.CustomEvent = customEvent;
})();

var Global = window;
(function(Global) {
	// set user access
	var RightCruise = Global.rightCruise = {
		// State of rightCruise, read only.
		setting: {},
		state: {},
		uncleanableState: {}
	};

	var Attr = {
		innerSize: ['innerWidth', 'innerHeight'],
		offsetValue: ['offsetLeft', 'offsetTop'],
		offsetPos: ['offsetX', 'offsetY'],
		clientSize: ['clientWidth', 'clientHeight'],
		clientValue: ['clientLeft', 'clientTop'],
		clientPos: ['clientX', 'clientY'],
		scrollSize: ['scrollWidth', 'scrollHeight'],
		scrollValue: ['scrollLeft', 'scrollTop'],
	};

	var Browser = {

		isIE: document.documentMode ? true : false,
		isChrome: 'WebkitAppearance' in document.documentElement.style,
		isWebkit: 'WebkitAppearance' in document.documentElement.style
	};

	var Setting = {

		autoActive: true,
		showState: true, // can only change here
		scrollMarkedElOnly: false,
		transmit: true,
		oneDirection: false,
		momentum:  true,
		maxHeight: undefined, // number(unit: px) or undefined(default, auto generated by evaluateStyle())
		zIndex: undefined, // number or undefined(622)
		stylesheet: {

			identity: {
				token: 'RC',
				seat: 0, // 0: initial, 1: tail
			},

			css: [
				/* example
				[
					selector: ['selector', 'selector', ...],
					property: {
						'prepertyName': value,
						'prepertyName': value,
						.
						.
						.
					}
				]
				*/
				{ // [0]
					selector: ['.mask_select'],
					property: {
						'z-index'   : undefined, // set by Setting.zIndex
						'position'  : 'absolute',
						'display'   : 'none',
						'opacity'   : '0.75'
					}
				},
				{ // [1]
					selector: ['.list_select'],
					property: {
						'z-index'   : undefined, // set by Setting.zIndex
						'position'  : 'absolute',
						'overflow-y': 'scroll',
						'background': '#FFF',
						/*
						'max-height': undefined,
						*/
					}
				},
				{ // [2]
					selector: ['.list_select > *'],
					property: {
						'padding-left': '0.25rem',
						'cursor'      : 'default'
					}
				},
				{ // [3]
					selector: ['.list_select > * > .option_select'],
					property: {
						'margin-left' : '-0.25rem', // countervail padding-left of optgroup
						'padding-left': '1rem',
					}
				},
				{ // [4]
					selector: [
						'.list_select > .option_select',
						'.list_select > * > *'
					],
					property: {
						//'height'     : '1.2rem',
						//'line-height': '1.2rem', // set text vertical-align to center
					}
				},
				// optgroup_select
				{ // [5]
					selector: ['.optgroup_select'],
					property: {
						'font-weight': 'bold',
						'color'      : '#000'
					}
				},
				// option_select
				{ // [6]
					selector: ['.option_select : not ( .disabled_select ) : hover'],
					property: {
						'background': '#666 !important',
						'color'     : '#FFF !important'
					}
				},
				// selected_select
				{ // [7]
					selector: ['.selected_select'],
					property: {
						'background' : '#666 !important',
						'font-weight': 'border',
						'color'      : '#FFF !important'
					}
				},
				// disabled_select
				{ // [8]
					selector: ['.disabled_select'],
					property: {
						'color': '#999 !important',
					}
				}
			]
		},
	};

	var IsBodyScrollable;

	var State = {
		// Boolean
		active: false,
		running: false, // throttle of cruise()
		evaluatePosChecked: false,
		transmit: true, // controled to be false by cruiseStart()
		firstCruise: true,
		// Number
		optHeight: 0,
		optgroupHeight: 0, // px, for duplicateOptionList_select()
		timemark: undefined, // for momentum()
		// Array
		startPos: [null, null],
		lastPos: [null, null],
		scrollState: [],
		scrollValue: [],
		scrollValueForMomentum: [undefined, undefined], // x, y
		evaluatePos: [0, 2],
		// node
		node: {
			affectedElement: [],
			scrolledElement: [null, null],
		},
		// timer
		timer: {

		}
	};

	var ClearState; // will mosify at sctive() and sleep(), for cruiseEnd()

	var UncleanableState = {

		onSelect: false, // on <select> clicked statues
		selectedIndex: undefined,
		scrollValue_selectList: 0,
		node: {
			hoveredSelect: null,
		},
		timer: {
			momentum: null,
		}
	};

	var Mask;

	function evaluateStyle() {

		var Stylesheet = Setting.stylesheet;
		var Css = Stylesheet.css;
		// z-index
		if (Setting.zIndex === undefined) { Setting.zIndex = 622; }
		/*
		Css[0].property['z-index'] = Css[1].property['z-index'] = Setting.zIndex;
		*/
		// max height of selectList
		if (Setting.maxHeight === undefined) { Setting.maxHeight = Math.round(window.innerHeight / 2) || 400; }
		/*
		Css[1].property['max-height'] = Setting.maxHeight + 'px';
		*/
	}

	function generateStyleSheet() {

		var styleTag = document.createElement('style');
		var Stylesheet = Setting.stylesheet;
		var Identity = Stylesheet.identity;
		var Token = Identity.token;
		var Seat = Identity.seat;
		var Css = Stylesheet.css;
		var text = '';
		var i;

		for (i = 0; i < Css.length; i++) {
			var selector = Css[i].selector;
			var property = Css[i].property;
			var keys_property = Object.keys(property);
			var j;
			// add token
			if (Token) {
				for (j = 0; j < selector.length; j++) {
					// separate
					var selectorEl = selector[j].split(' ');
					var k;
					// add token
					for (k = 0; k < selectorEl.length; k++) {
						var firstChar = selectorEl[k].charAt(0);

						if (firstChar === '#' || firstChar === '.') {

							var clearEl = selectorEl[k].replace('#', '').replace('.', '');

							selectorEl[k] = firstChar + (Seat ? clearEl + Token : Token + clearEl);
						}
					}
					// combine
					selector[j] = selectorEl.join().replace(/,/g, '');
				}
			}
			// combine text
			text += selector.join() + ' {\n';

			for (j = 0; j < keys_property.length; j++) {
				text += keys_property[j] + ': ' + property[keys_property[j]] + ';\n';
			}

			text += '}\n';
		}

		styleTag.appendChild(document.createTextNode(text));

		return styleTag;
	}

	function active(settings, callback) {

		if (document.readyState !== 'complete') {
			window.requestAnimationFrame(function() {

				active(settings);
			});

			return;
		}

		if (settings) {
			var attr;

			for (attr in settings) {
				if (Setting[attr] !== undefined && attr !== 'showState') { Setting[attr] = settings[attr]; }
			}
		}

		if (!State.active) {
			// check body scrollable
			IsBodyScrollable = Is.bodyScrollable();
			// evaluate style value
			evaluateStyle();
			// install styleTag
			document.head.appendChild(generateStyleSheet());
			// install mask
			installMask_select();
			// handle event catcher
			eventCatcherHandler(1);
			// update state
			State.active = true;
			console.log('rightCruise is activated.');
		} else {
			console.log('rightCruise is already activated.');
		}
		// restore clearState
		ClearState = JSON.stringify(State);
		// update state for user
		updateState();
		// callback
		if (arguments[0] && arguments.length === 1 && settings.constructor === Function) { callback = settings; }
		if (callback) { callback(); }
	}

	function sleep() {

		if (State.active) {
			// eliminate mask
			Mask.parentNode.removeChild(Mask);
			Mask = undefined;
			// handle event catcher
			eventCatcherHandler(0);
			// update state
			State.active = false;
			console.log('rightCruise is sleeping.');
		} else {
			console.log('rightCruise is not activated.');
		}
		// restore clearState
		ClearState = JSON.stringify(State);
		// update state for user
		updateState();
	}

	function set(settings) {

		var acceptedKeys = [
			'scrollMarkedElOnly',
			'transmit',
			'oneDirection',
			'momentum',
			'maxHeight',
			'zIndex'
		];
		var attr;

		for (attr in settings) {
			if (acceptedKeys.indexOf(attr) !== -1) { Setting[attr] = settings[attr]; }
		}
	}

	function eventCatcherHandler(Switch) {

		var method = (Switch ? 'add' : 'remove') + 'EventListener';

		document[method]('mousedown', cruiseStart, false);
		// for selectElement()
		document[method]('mouseover', mouseover_select, false);
	}

	function cruiseStart(e) { // triggered by mousedown(right button)
		//console.log('rightCruise');
		if (e.button === 2) {

			var Path = e.path || Get.path(e.target);
			console.log(Path);
			var selectList = document.getElementById('selectList');
			var scrollable = collectAffectedEl(Path);
			var i;
			// clear momentum
			clearInterval(UncleanableState.timer.momentum);
			// if cruise selectList, turn off transmit
			if (UncleanableState.onSelect && Is.descendant(e.target, selectList)) {
				State.transmit = false;
			}
			scrollable = collectAffectedEl(Path);
			//console.log('affectedElement', State.node.affectedElement);
			//console.log('scrollValue', State.scrollValue);
			if (scrollable) {
				// record timemark for momentum
				State.timemark = e.timeStamp;
				// update start-position
				State.startPos = [e.clientX, e.clientY];
				// handle event catcher
				document.addEventListener('mousemove', cruise, false);
				document.addEventListener('contextmenu', cruiseEnd, false);
			}
		}
		// update state for user
		updateState();
	}

	function cruise(e) { // triggered by mousemove, after cruiseStart triggered
		//console.log('cruise');
		if (State.running) { return; }
		// update running state
		State.running = true;

		window.requestAnimationFrame(function() {
			/*
				window.requestAnimationFrame has a chance to execute after user release right button,
				so check State.running again.
			*/
			if (State.running === false) { return; }
			//console.log('move');
			var movePos = [e.clientX, e.clientY];
			// get gap
			var gap = [
				State.startPos[0] - movePos[0],
				State.startPos[1] - movePos[1]
			];
			var absGap = [
				Math.abs(gap[0]),
				Math.abs(gap[1])
			];
			// check if one direction, if so, check direction
			if (Setting.oneDirection && !State.evaluatePosChecked) {
				var distanceFromStart = Math.sqrt(Math.pow(absGap[0], 2) + Math.pow(absGap[1], 2));

				if (distanceFromStart > 1) {
					// update to checked
					State.evaluatePosChecked = true;
					// check and set evaluatePos
					State.evaluatePos[0] = (absGap[0] > absGap[1]) ? 0 : 1;
					State.evaluatePos[1] = State.evaluatePos[0] + 1;
				}
			}

			var isMomentum = Setting.momentum;
			var afEl = State.node.affectedElement;
			// get unfitScrollState, 0: minimum, 2: maximum
			var unfitScrollState = [
				(gap[0] < 0) ? 0 : 2, // x
				(gap[1] < 0) ? 0 : 2  // y
			];
			var iStart = State.evaluatePos[0];
			var iLength = State.evaluatePos[1];
			var i, j;

			if (isMomentum) {
				State.lastPos = movePos;

				if (State.firstCruise) {
					State.firstCruise = false;
					State.node.scrolledElement = [afEl[0], afEl[0]];
					State.scrollValueForMomentum = State.scrollValue[0];
				}
			}
			// check scrolledElement, scrollLeft(x)
			for (i = iStart; i < iLength; i++) {
				for (j = 0; j < afEl.length; j++) {
					var el = afEl[j];

					if (
						State.scrollState[j][i] !== 3 &&
						State.scrollState[j][i] !== unfitScrollState[i]
					) {
						el[Attr.scrollValue[i]] = State.scrollValue[j][i] + gap[i];

						if (isMomentum) {
							State.node.scrolledElement[i] = el;
							State.scrollValueForMomentum[i] = State.scrollValue[j][i];
						}

						break; // break loop j
					}
					// <HTML>, last
					if (el === document.documentElement) { break; }
					// transmit
					if (!Setting.transmit || !State.transmit) { break; } // break loop j
				}
			}
			// update running state
			State.running = false;
			// cast cruise event
			castCustomEvent(document, 'cruise', {});
		});
		// update state for user
		updateState();
	}

	function cruiseEnd(e) { // triggered by contextmenu(right button click), after cruiseStart triggered
		
		var movePos = [e.clientX, e.clientY];
		// get gap
		var gap = [
			State.startPos[0] - movePos[0],
			State.startPos[1] - movePos[1]
		];
		var absGap = [
			Math.abs(gap[0]),
			Math.abs(gap[1])
		];
		var distanceFromStart = Math.sqrt(Math.pow(absGap[0], 2) + Math.pow(absGap[1], 2));
		//console.log(distanceFromStart);
		if (distanceFromStart > 1) {
			console.log('Cruise end');
			e.preventDefault();
			// momentum
			if (Setting.momentum) {
				var lastPosGap = (State.lastPos[0] - movePos[0]) - (State.lastPos[1] - movePos[1]);
				//console.log(lastPosGap);
				if (lastPosGap !== 0) {

					var els = State.node.scrolledElement;
					var ScrollValue = State.scrollValueForMomentum;
					var distance = [
						els[0].scrollLeft - ScrollValue[0],
						els[1].scrollTop - ScrollValue[1]
					];
					var duration = e.timeStamp - State.timemark;

					momentum(els, distance, duration);
				}
			}
			// cast cruiseend event
			castCustomEvent(document, 'cruiseend', {});
		} else {
			console.log('Call contextmenu');
		}
		// clean State
		//console.log('Clean State');
		State = JSON.parse(ClearState);
		// remove event-catcher
		document.removeEventListener('mousemove', cruise, false);
		document.removeEventListener('contextmenu', cruiseEnd, false);
		// update state for user
		updateState();
	}

	function updateState() { // for user, accessible via rightCruise, read only

		if (!Setting.showState) { return; }

		var attr;

		for (attr in Setting) {
			RightCruise.setting[attr] = Setting[attr];
		}

		for (attr in State) {
			RightCruise.state[attr] = State[attr];
		}

		for (attr in UncleanableState) {
			RightCruise.state[attr] = UncleanableState[attr];
		}
	}

	function momentum(els, distance, duration) {
		//console.log(els, distance, duration);
		var fps = 60; // frames per second
		var dpf = parseInt(1000 / fps); // duration(millionseconds) per frame
		var friction = 25 / 1000; // px per millionseconds
		var run = [1, 1];
		var speed = []; // pxs per millionseconds
		var delta = []; // 1: positive, -1: negative
		var scrollValue_max = []; // scrollLeft, scrollTop
		var i;
		// evaluate speed, delta, scrollValue_max
		for (i = 0; i < 2; i++) {
			speed.push(Math.abs(distance[i] / duration));
			delta.push(distance[i] >= 0 ? 1 : -1);
			scrollValue_max.push(Get.scrollValue_max(els[i], i));
		}
		// clear old
		clearInterval(UncleanableState.timer.momentum);
		// set new
		UncleanableState.timer.momentum = setInterval(function() {
			// momentum
			for (i = 0; i < 2; i++) {
				if (!run[i]) continue;

				var el = els[i];
				var scrollLength = speed[i] * dpf;
				
				el[Attr.scrollValue[i]] += delta[i] * scrollLength;

				if (
					el[Attr.scrollValue[i]] === scrollValue_max[i] ||
					el[Attr.scrollValue[i]] === 0 ||
					speed[i] <= 0
				) run[i] = 0;
				// update speed
				speed[i] -= friction;
			}
			// check if end
			if (!run[0] && !run[1]) {
				clearInterval(UncleanableState.timer.momentum);
				// cast momentumend event
				castCustomEvent(document, 'momentumend', {});
			}
		}, dpf);
	}

	/*
		subjective functions
	*/

	function collectAffectedEl(els) {
		// collect affected element and it's scrollState, scrollValue
		var scrollable = false;

		for (i = 0; i < els.length; i++) {
			var el = els[i];
			// <html>, last element
			if (el === document.body) { break; }

			if (Setting.scrollMarkedElOnly) {
				if (el.getAttribute('cruisemark') !== 'true') { continue; } // skip
			} else {
				// scrollType 3: not scrollable
				console.log(el);
				if (Determine.scrollType(el) === 3) { continue; } // skip
			}
			// scrollable
			scrollable = true;
			// for body of not Chrome browser
			el = (el === document.body && !IsBodyScrollable) ? document.documentElement : el;
			// collect
			State.node.affectedElement.push(el);
			State.scrollState.push(Determine.scrollState(el));
			State.scrollValue.push([
				el.scrollLeft,
				el.scrollTop
			]);
		}

		return scrollable;
	}

	/*
		System modifications
	*/

	function installMask_select() {
		// generate after document is ready
		if (document.readyState !== 'complete') {
			window.requestAnimationFrame(installMask_select);
			return;
		}
		// generate Mask and set access
		Mask = document.createElement('div');

		Mask.classList.add('RCmask_select');

		document.body.appendChild(Mask);
		// handle event catcher
		Mask.addEventListener('click', clickMask_select, false);
		Mask.addEventListener('mouseout', mouseoutMask_select, false);
		console.log('Mask of <select> is generated.');
	}

	function mouseover_select(e) {

		if (
			e.target.tagName === 'SELECT' &&
			!(e.target.multiple || e.target.size)
		) {
			var select = e.target;
			var borderWidth = parseFloat(getComputedStyle(select).borderTopWidth);
			var width = select.clientWidth;
			var height = select.clientHeight;
			var clientPos = Get.clientPos(select, {ancestors: [document.body]});
			// if border width is not 0
			if (borderWidth) {
				width += borderWidth * 2;
				height += borderWidth * 2;
			}
			// set style
			Mask.style.cssText +=
				'display: block;' +
				'left: ' + clientPos[0] + 'px;' +
				'top: ' + clientPos[1] + 'px;' +
				'width: ' + width + 'px;' +
				'height: ' + height + 'px;';
			// update state
			UncleanableState.node.hoveredSelect = select;
			updateState();
		}
	}

	function mouseoutMask_select() {

		Mask.style.display = 'none';
	}

	function clickMask_select(e) {
		// set onSelect state
		UncleanableState.onSelect = true;
		// set activeElement = select
		UncleanableState.node.hoveredSelect.focus();
		// generate list, append it to <body> then scroll it to selected index
		var list = duplicateOptionList_select();

		list.scrollTop = UncleanableState.scrollValue_selectList;
		// handle event catcher at next tick
		window.requestAnimationFrame(function() {
			list.addEventListener('click', eliminateList_select, false);
			document.addEventListener('mousedown', eliminateList_select, false);
			document.addEventListener('wheel', eliminateList_select, false);
		});
	}

	function duplicateOptionList_select() {

		var Sup = duplicateOptionList_select.sup;
		var select = UncleanableState.node.hoveredSelect;
		var children = select.children;
		var width = Mask.clientWidth;
		var height = Mask.clientHeight;
		var clientPos = Get.clientPos(select, {ancestors: [document.body]});
		var list = document.createElement('div');
		var Styles = getComputedStyle(select);
		var borderWidth = parseFloat(Styles.borderTopWidth) || 1;
		var topPos_list = clientPos[1] + height;
		var maxHeight = Math.min(Setting.maxHeight, (window.innerHeight - 25 * 2));
		var heightGap = (topPos_list + maxHeight) - (window.innerHeight + (window.scrollY || document.documentElement.scrollTop) - 25);
		var amount_checkedOption = 0;
		var amount_checkedOptgroup = 0;
		var i, j;
		// clear selectedIndex
		UncleanableState.selectedIndex = undefined;
		// generate border value
		borderStyle = 'border: ' + borderWidth + 'px ' + (Styles.borderTopStyle || 'solid') + ' ' + (Styles.borderTopColor || '#CCC') + ';';
		console.log(borderStyle);
		// set id
		list.id = 'selectList';
		// set style
		list.classList.add('RClist_select');
		// adjust position of list
		if (heightGap > 0) { topPos_list -= heightGap; }
		// set stylea
		list.style.cssText =
			'z-index: ' + Setting.zIndex + ';' +
			'left: ' + clientPos[0] + 'px;' +
			'top: ' + topPos_list + 'px;' +
			'max-height: ' + maxHeight + 'px;' +
			'min-width: ' + width + 'px;' +
			'font-family: ' + Styles.fontFamily + ';' +
			'font-size: ' + Styles.fontSize + ';' +
			borderStyle;
		// append list to <body>
		document.body.appendChild(list);
		// generate optgroup, option and append them to list
		for (i = 0; i < children.length; i++) {
			var child = children[i];
			var isOptgroup = (child.tagName === 'OPTGROUP');
			var duplicate = Sup.generateDuplicate(child);
			// check if selected
			Sup.checkSelected(child, duplicate);
			// append duplicate to list
			list.appendChild(duplicate);
			// if child = <optgroup>
			if (isOptgroup) { //HERE
				var options = child.getElementsByTagName('option');
				// get optgroupHeight
				if (!State.optgroupHeight) { State.optgroupHeight = parseFloat(getComputedStyle(duplicate).height); }
				// counting amount of optgroup
				if (UncleanableState.selectedIndex === undefined) { amount_checkedOptgroup += 1; }

				for (j = 0; j < options.length; j++) {
					// duplicate option
					var duplicate_option = Sup.generateDuplicate(options[j]);
					// check if selected
					Sup.checkSelected(options[j], duplicate_option);
					// append option_duplicate to optgroup_duplicate
					duplicate.appendChild(duplicate_option);
					// get optgroupHeight
					if (!State.optionHeight) { State.optionHeight = parseFloat(getComputedStyle(duplicate_option).height); }
					// counting amount of option
					if (UncleanableState.selectedIndex === undefined) { amount_checkedOption += 1; }
				}
			} else {
				// counting amount of option
				if (UncleanableState.selectedIndex === undefined) { amount_checkedOption += 1; }
			}
		}
		// auto-scroll to selected option at next tick
		if (UncleanableState.selectedIndex !== undefined) {
			UncleanableState.scrollValue_selectList = Math.round(amount_checkedOptgroup * State.optgroupHeight + amount_checkedOption * State.optionHeight);
		}

		return list;
	}

	duplicateOptionList_select.sup = {
		
		generateDuplicate: function(el) {

			var isGroup = (el.tagName === 'OPTGROUP');
			var isDisabled = el.disabled;
			var classes = el.classList;
			var duplicate = document.createElement('div');
			var title;

			if (isGroup) {
				title = document.createElement('div');
				duplicate.appendChild(title);
			} else {
				title = duplicate;
			}
			// set style
			title.classList.add(isGroup ? 'RCoptgroup_select' : 'RCoption_select');
			// copy style from el to title
			[].forEach.call(classes, function(token) { title.classList.add(token); });
			title.style.cssText = el.style.cssText;
			// set attribute
			if (isDisabled) { title.classList.add('RCdisabled_select'); }
			// set text
			title.appendChild(document.createTextNode(isGroup ? el.label : el.text));
			// if el = option
			if (!isGroup) {
				// set index value for clickOption_select()
				duplicate.setAttribute('value', isDisabled ? -1 : el.index);
				// handle event catcher
				duplicate.addEventListener('click', clickOption_select, false);
			}

			return duplicate;
		},

		checkSelected: function(origin, duplicate) {

			if (UncleanableState.selectedIndex === undefined && origin.selected) {
				UncleanableState.selectedIndex = origin.index;
				duplicate.classList.add('RCselected_select');
			}
		}
	};

	function clickOption_select() {
		// this = option of list
		var value = this.getAttribute('value');
		var select = UncleanableState.node.hoveredSelect;
		// set activeElement = select
		select.focus();

		if (value === '-1') { // disabled
			return;
		}

		select.selectedIndex = value;
		// trigger change event
		var evt;

		if ('createEvent' in document) {

			evt = document.createEvent('HTMLEvents');

			evt.initEvent('change', true, false);
		} else if (CustomEvent) {
			evt = new CustomEvent('change');
		}

		select.dispatchEvent(evt);
	}

	function eliminateList_select(e) {

		var selectList = document.getElementById('selectList');

		if (
			e.target.getAttribute('value') === '-1' || // option is disabled
			(
				Is.descendant(e.target, selectList) &&
				(e.type === 'mousedown' || e.type === 'wheel')
			)
		) { return; }
		// hide Mask
		Mask.style.display = 'none';
		// eliminate selectList
		document.body.removeChild(selectList);
		// handle event catcher
		selectList.removeEventListener('click', eliminateList_select, false);
		document.removeEventListener('mousedown', eliminateList_select, false);
		document.removeEventListener('wheel', eliminateList_select, false);
		// set onSelect state
		UncleanableState.onSelect = false;
	}

	/*
		Helpers
	*/
	var IsMouseExist = {

		untilDoFunc: null,

		init: function() {

			this.eventHandler(1);
		},

		catcher: function(e) {

			var isMouseExist = (e.constructor === MouseEvent);
			var self = IsMouseExist;

			if (isMouseExist) {
				if (self.untilDoFunc) { self.untilDoFunc(); }
			}

			self.eventHandler(0);

			self = (isMouseExist);
			console.log('Mouse exist:', self);
		},

		untilCheckedDo: function(func) {

			this.untilDoFunc = func;
		},

		eventHandler: function(Switch) {

			var eventName = [
				'mousedown',
				'mousemove',
				'touchstart'
			];
			var i;

			for (i = 0; i < eventName.length; i++) {
				document[(Switch ? 'add' : 'remove') + 'EventListener'](eventName[i], this.catcher, false);
			}
		}
	};

	var Is = {

		descendant: function(el, ancestor) {

			var Path = Get.path(el);
			var returnValue = false;
			var i;

			for (i = 0; i < Path.length; i++) {
				if (Path[i] === ancestor) {
					returnValue = true;
					break;
				}
			}

			return returnValue;
		},

		bodyScrollable: function() { // check at initial

			var body = document.body;
			var bodyWidth = body.style.width || 0;
			var windowWidth = document.documentElement.clientWidth;
			var bodyScrollLeft = body.scrollLeft;
			// prepare
			body.style.width = Math.max(parseFloat(bodyWidth), windowWidth) + 1 + 'px';
			body.scrollLeft = 1;
			// check
			var scrollable = body.scrollLeft ? true : false;
			// recover
			body.scrollLeft = bodyScrollLeft;
			body.style.width = bodyWidth ? bodyWidth : null;
			console.log('Body scrollable:', scrollable);

			return scrollable;
		},
	};

	var Get = {

		path: function(firstElement) {
			// return [firstElement, firstElement.parentNode, ..., body]
			if (firstElement === document.documentElement) {
				console.log('<html> has no ancestors.');
				return [];
			}

			var path = [firstElement];
			var i;

			if (firstElement === document.body) return path;

			for (i = 0; i < path.length; ++i) {
				path.push(path[i].parentNode);

				if (path[i].parentNode === document.body) return path;
			}
		},

		clientPos: function(el, args) { // clientLeft, clientTop, dir: 0(x), 1(y), undefined(both)
			/*
			args = {
				ancestors: [](Get.path(el).shift()),
				dir: number(0: x, 1: y)
			}
			*/
			var ancestors = args.ancestors;
			var dir = args.dir;
			var clientRect = el.getBoundingClientRect();
			var clientPos = [clientRect.left, clientRect.top];
			var jStart = (dir !== undefined) ? dir : 0;
			var jLength = (dir !== undefined) ? (dir + 1) : 2;
			var i, j;

			for (i = 0; i < ancestors.length; i++) {
				for (j = jStart; j < jLength; j++) {
					if (ancestors[i] === document.body && !IsBodyScrollable) {
						ancestors[i] = document.documentElement;
					}

					clientPos[j] += ancestors[i][Attr.scrollValue[j]];
				}
			}

			return (dir !== undefined) ? clientPos[dir] : clientPos;
		},

		scrollValue_max: function(el, dir) { // dir: direction, 0: x, 1:y

			var isBody = (el === document.body);
			var scrollValue_max, scrollSize, size;

			el = isBody ? (IsBodyScrollable ? document.body : document.documentElement) : el; 
			size = isBody ? window[Attr.innerSize[dir]] : el[Attr.clientSize[dir]];
			scrollSize = el[Attr.scrollSize[dir]];
			scrollValue_max = scrollSize - size;

			return scrollValue_max;
		},
	};

	var Determine = { // for all elements

		scrollType: function(el) {
			// return 0: x only, 1: y only, 2: both, 3: none
			var scrollType = 3;
			var Size, ScrollSize;
			var Styles = getComputedStyle(el);
			var OfX = Styles.overflowX;
			var OfY = Styles.overflowY;
			var i;

			Size = [null, null];
			ScrollSize = [null, null];

			if (el === document.body) {
				// even overflow = visible, if size of contents is larger then browser window,
				// it's would be scrollable
				if (OfX !== 'hidden') { // x may be scrollable
					Size[0] = window.innerWidth;
					ScrollSize[0] = el.scrollWidth;
				}

				if (OfY !== 'hidden') { // y may be scrollable
					Size[1] = window.innerHeight;
					ScrollSize[1] = el.scrollHeight;
				}

			} else {
				var isTextarea = (el.tagName === 'TEXTAREA');

				if ( // x may be scrollable
					OfX === 'auto' ||
					OfX === 'scroll' ||
					// for IE
					(OfX === 'visible' && OfY === 'hidden') ||
					// for <textarea> in firefox
					(isTextarea && OfX === 'visible')
				) {
					Size[0] = el.clientWidth;
					ScrollSize[0] = el.scrollWidth;
				}

				if ( // y may be scrollable
					OfY === 'auto' ||
					OfY === 'scroll' ||
					// for IE
					(OfY === 'visible' && OfX === 'hidden') ||
					// for <textarea> in firefox
					(isTextarea && OfY === 'visible')
				) {
					Size[1] = el.clientHeight;
					ScrollSize[1] = el.scrollHeight;
				}
			}
			// check x
			if (Size[0]) {
				if (Size[0] < ScrollSize[0]) scrollType = 0; // x only
			}
			// check y
			if (Size[1]) {
				if (Size[1] < ScrollSize[1]) {
					scrollType = (scrollType === 0) ? 2 : 1; // both : y only
				}
			}

			return scrollType;
		},

		scrollState: function(el, dir) { // dir(direction) 0: horizontal, 1: vertical
			// return value 0: minimum, 1: in-between, 2: maximum, 3: no-scrollbar
			var ScrollType = Determine.scrollType(el);
			var check = function(dir) {

				var Size = (el === document.body) ? window[Attr.innerSize[dir]] : el[Attr.clientSize[dir]];
				var ScrollSize = el[Attr.scrollSize[dir]];
				// check none of scrollbar
				if (Size >= ScrollSize) return 3; // none of scrollbar
				// check minimum
				var ScrollValue = el[Attr.scrollValue[dir]];

				if (ScrollValue === 0) return 0; //minimum
				// check in-between, maximum
				var scrollValue_max = ScrollSize - Size;

				return (Math.abs(ScrollValue - scrollValue_max) < 1) ? 2 : 1; // maximum : in-between
			};

			if (ScrollType === 0) { // scrollbar x only
				return (dir === undefined) ? [check(0), 3] : (dir === 0) ? check(dir) : 3;
			}

			if (ScrollType === 1) { // scrollbar y only
				return (dir === undefined) ? [3, check(1)] : (dir === 1) ? check(dir) : 3;
			}

			if (ScrollType === 2) { // both
				return (dir === undefined) ? [check(0), check(1)] : check(dir);
			}

			if (ScrollType === 3) return 3; // no-scrollbar
		},
	};

	function castCustomEvent(el, name, details) { // details: Object
		
		var customEvent = new CustomEvent(name, details);

		el.dispatchEvent(customEvent);
	}

	/*
		Initializing
	*/

	// set user-accessible methods
	RightCruise.active = active;
	RightCruise.sleep = sleep;
	RightCruise.set = set;
	// check if showState
	if (!Setting.showState) {
		delete RightCruise.setting;
		delete RightCruise.state;
		delete RightCruise.uncleanableState;
	}
	// check if autoActive
	if (Setting.autoActive) {
		IsMouseExist.init();
		IsMouseExist.untilCheckedDo(rightCruise.active);
		//rightCruise.active();
	}
	// update state for user
	updateState();
}(window));
